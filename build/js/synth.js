// Generated by CoffeeScript 1.4.0
(function() {
  var CHANNELS, DURATION, GAIN, SIGNAL_LEN, SRATE, avg, dampness, firefox_on_linux, interpolate, ks_noise_sample, make_dual_channel, mk_point, mk_ring_cleaner, mk_wave_shape, mkbuf, mksink, oud_signal_gen, oud_wave_shape, period_len, probability, random_sample, string_type_factory, tone_gen, tone_signal, tonefreq, wave_shape_to_sample;

  mkbuf = function(len) {
    return new Float32Array(Math.floor(len));
  };

  firefox_on_linux = function() {
    return $.browser.mozilla && (navigator.platform.indexOf("Linux") !== -1 || navigator.oscpu.indexOf("Linux") !== -1);
  };

  CHANNELS = 2;

  mksink = function(srate) {
    var prebuf_size;
    try {
      prebuf_size = firefox_on_linux() ? srate / 2 : 2048;
      prebuf_size = Math.floor(prebuf_size);
      return Sink(null, CHANNELS, prebuf_size, srate);
    } catch (error) {
      alert("الرجاء فتح الموقع فيمتصفح كووكل كروم");
      return {
        sampleRate: srate,
        ringOffset: 0
      };
    }
  };

  window.dev = mksink(44100);

  SRATE = dev.sampleRate;

  period_len = function(freq) {
    return Math.round(SRATE / freq);
  };

  avg = function(a, b) {
    return (a + b) / 2;
  };

  probability = function(p) {
    return Math.random() < p;
  };

  ks_noise_sample = function(val) {
    if (val == null) {
      val = 0.5;
    }
    if (probability(0.5)) {
      return val;
    } else {
      return -val;
    }
  };

  random_sample = function() {
    return 2 * Math.random() - 1;
  };

  mk_point = function(x, y) {
    return {
      x: x,
      y: y
    };
  };

  mk_wave_shape = function(points) {
    if (points[0].x !== 0) {
      points.unshift(mk_point(0, 0));
    }
    if (points[points.length - 1].x !== 1) {
      points.push(mk_point(1, 0));
    }
    return points;
  };

  interpolate = function(v1, v2, dist) {
    return (v2 - v1) * dist + v1;
  };

  wave_shape_to_sample = function(shape, len) {
    var dist, i, next, prev, s, sample, x, _i, _len;
    shape = Object.clone(shape);
    sample = mkbuf(len);
    prev = shape.shift();
    for (i = _i = 0, _len = sample.length; _i < _len; i = ++_i) {
      s = sample[i];
      next = shape[0];
      x = i / len;
      dist = (x - prev.x) / (next.x - prev.x);
      sample[i] = interpolate(prev.y, next.y, dist);
      if (x > next.x) {
        prev = shape.shift();
      }
    }
    return sample;
  };

  oud_wave_shape = mk_wave_shape([mk_point(0.1, 0.1), mk_point(0.16, 0.22), mk_point(0.26, -0.26), mk_point(0.4, -0.22), mk_point(0.5, 0.1), mk_point(0.6, 0.34), mk_point(0.7, 0.24), mk_point(0.84, 0), mk_point(0.91, -0.04)]);

  DURATION = 1.1;

  GAIN = 0.7;

  SIGNAL_LEN = DURATION * SRATE * CHANNELS;

  dev.ringBuffer = mkbuf(7 * CHANNELS * SRATE);

  dampness = (function() {
    var down, point, _i, _results;
    down = function(val) {
      return Math.max(0, val - 0.24);
    };
    _results = [];
    for (point = _i = 0; 0 <= SIGNAL_LEN ? _i <= SIGNAL_LEN : _i >= SIGNAL_LEN; point = 0 <= SIGNAL_LEN ? ++_i : --_i) {
      _results.push(down(Math.pow(Math.E, -2 * (point / SIGNAL_LEN))));
    }
    return _results;
  })();

  string_type_factory = function(wave_shape, noise_sample_param) {
    var signal_gen;
    return signal_gen = function(freq) {
      var adj, base_sample, index, point, s, signal, table, table_len, _i, _j, _len, _len1;
      table_len = period_len(freq);
      table = mkbuf(table_len);
      base_sample = wave_shape_to_sample(wave_shape, table_len);
      for (index = _i = 0, _len = base_sample.length; _i < _len; index = ++_i) {
        s = base_sample[index];
        table[index] = base_sample[index] + ks_noise_sample(noise_sample_param);
      }
      signal = mkbuf(SIGNAL_LEN);
      for (index = _j = 0, _len1 = signal.length; _j < _len1; index = ++_j) {
        s = signal[index];
        point = index % table_len;
        adj = (table_len + index - 1) % table_len;
        table[point] = avg(table[point], table[adj]);
        signal[index] = table[point];
      }
      return signal;
    };
  };

  oud_signal_gen = string_type_factory(oud_wave_shape, 0.12);

  tonefreq = function(tone, base) {
    var tones_per_octave;
    if (base == null) {
      base = 128;
    }
    tones_per_octave = 53;
    return base * Math.pow(2, tone / tones_per_octave);
  };

  tone_signal = {};

  tone_gen = function(tone) {
    if (tone in tone_signal) {
      return tone_signal[tone];
    } else {
      return tone_signal[tone] = signal_gen_from_freq(tonefreq(tone));
    }
  };

  window.signal_gen_from_freq = function(freq) {
    var point, s, signal, signal_raw, signal_raw2, _i, _len;
    signal_raw = oud_signal_gen(freq);
    signal_raw2 = oud_signal_gen(freq);
    signal = mkbuf(SIGNAL_LEN);
    for (point = _i = 0, _len = signal.length; _i < _len; point = ++_i) {
      s = signal[point];
      signal[point] = (signal_raw[point] + signal_raw2[point]) * dampness[point] * GAIN;
    }
    return make_dual_channel(signal);
  };

  make_dual_channel = function(signal) {
    var index, s, signal2, _i, _len;
    signal2 = mkbuf(signal.length * 2);
    for (index = _i = 0, _len = signal2.length; _i < _len; index = ++_i) {
      s = signal2[index];
      signal2[index] = signal[Math.floor(index / 2)];
    }
    return signal2;
  };

  window.play_freq = function(freq) {
    return play_signal(signal_gen_from_freq(freq));
  };

  window.playtone = function(tone) {
    var signal;
    signal = tone_gen(tone);
    return play_signal(signal);
  };

  window.play_signal = function(signal) {
    var point, ringlen, sample, _i, _len;
    point = dev.ringOffset;
    ringlen = dev.ringBuffer.length;
    for (_i = 0, _len = signal.length; _i < _len; _i++) {
      sample = signal[_i];
      point = (point + 1) % ringlen;
      dev.ringBuffer[point] += sample;
    }
    return true;
  };

  mk_ring_cleaner = function() {
    var clean_ring, len, prev_offset;
    prev_offset = 0;
    len = dev.ringBuffer.length;
    return clean_ring = function() {
      var end, offset, point;
      offset = dev.ringOffset;
      point = prev_offset;
      end = offset < prev_offset ? len + offset : offset;
      while (point < end) {
        dev.ringBuffer[point % len] = 0;
        point++;
      }
      return prev_offset = offset;
    };
  };

  setInterval(mk_ring_cleaner(), 200);

}).call(this);
